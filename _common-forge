# vim: set ft=make:
#
# Copyright (c) 2016-2017, Ryan V. Bissell
# All rights reserved.
#
# SPDX-License-Identifier: MIT
# See the enclosed "LICENSE.forge" file for exact license terms.
#

ifndef __cf_include_guard
override __cf_include_guard:=1

ifndef cfout
_cfcommon:=$(notdir $(lastword $(MAKEFILE_LIST)))
_cfcaller:=$(notdir $(lastword $(wordlist 2,$(words $(MAKEFILE_LIST)),foo $(MAKEFILE_LIST))))
$(error INTERNAL ERROR: $(_cfcaller) should have guaranteed that 'cfout' was defined before including $(_cfcommon))
endif
$(cfout):
	@$(test) mkdir -p $(cfout)


# TODO, add check for CF defined here

# TODO, see make-forge
########.PHONY: clean


# .d files are precious because they serve to speed up subsequent builds.
# .i files are precious because the user specifically asked for them.
.PRECIOUS: $(cfout)/%.d $(cfout)/%.i


# enable paralellism based on number of available processors
# I believe this is the most portable solution (nearly POSIX)
override CF_NUMPROCS?=$(shell getconf _NPROCESSORS_ONLN)
override MAKEFLAGS+= --jobs=$(CF_NUMPROCS)
ifdef VERBOSE
define verbose =
    $(info V: $1)
endef
endif
$(call verbose,This session will use $(cf_numprocs) processor(s))

# group parallel output on a per-target basis,
# and squelch unhelpful output from Make
# TODO: the --output-sync line will make stderr undetectable by stderred
override MAKEFLAGS+= --output-sync=target
override MAKEFLAGS+= --no-print-directory



# TODO: these should be specific to the host OS
override mfobj:=o
override mflib:=a
override mfexe:=
override mfdll:=so


# TODO: some of these may be specific to the host OS
ifdef TEST
    override test:=echo
    override test2:=>/dev/null $(test)
    override pipe:=\|
    override redir:=\>
    override indir:=\<
    override append:=\>\>
    ifeq ($(TEST),2)
        override test2:=$(test)
    endif
else
    override test:=
    override test2:=
    override pipe:=|
    override redir:=>
    override indir:=<
    override append:=>>
endif

ifdef DEBUG
    override CXXFLAGS+= -ggdb3 -O0
endif

override empty:=
override tab:=$(empty)	$(empty)
override space:=$(empty) $(empty)
override comma:= ,

override echo:=echo
ifdef CF_QUIET_BUILDS
    override echo:=>/dev/null echo
endif


# save off the original values of CXXFLAGS, etc, so that we
# can restore them a the start of every target declaration
override CF_CFLAGS:=$(CFLAGS)
override CF_LDFLAGS:=$(LDFLAGS)
override CF_CPPFLAGS:=$(CPPFLAGS)
override CF_CXXFLAGS:=$(CXXFLAGS)

# traditionally, ARFLAGS defaults to 'rv', but we like 'rcs' here
override CF_ARFLAGS:=rcs

# ---------------------------------------------------------------------
# INTERNAL:     __cf_initialize
# Description:  Resets internal state, in preparation for
#               cf_declare_target, et al.
# ---------------------------------------------------------------------
define __cf_initialize =
    $(eval override LDLIBS:=)
    $(eval override CFLAGS:=$(CF_CFLAGS))
    $(eval override ARFLAGS:=$(CF_ARFLAGS))
    $(eval override LDFLAGS:=$(CF_LDFLAGS))
    $(eval override CPPFLAGS:=$(CF_CPPFLAGS))
    $(eval override CXXFLAGS:=$(CF_CXXFLAGS))
    $(eval override mf_suffix:=)
    $(eval override mf_printsuffix:=)
    $(eval override mf_srcfiles:=)
    $(eval override mf_objfiles:=)
    $(eval override mf_depfiles:=)
    $(eval override mf_libfiles:=)
    $(eval override mf_linkfiles:=)
    $(eval override mf_deptargets:=)
endef


# ---------------------------------------------------------------------
# Function:     cf_declare_target(name)
# Description:  Declares to make-forge that a new build-target named
#               'name' is about to be described.
# Arguments: 1: name of the build-target being described
# ---------------------------------------------------------------------
define $(CF)_declare_target =
    $(eval $(call __cf_initialize))
    $(eval override mf_target:=$(CF_NAMESPACE)$(1))
    $(eval override mf_outdir:=$(cfout))
endef


# ---------------------------------------------------------------------
# Function:     cf_set_object_suffix(suffix)
# Description:  Sets a filename stem suffix for every object file
#               built for this build-target
# Arguments: 1: What the suffix should be set to
# ---------------------------------------------------------------------
define $(CF)_set_object_suffix =
    $(eval override mf_suffix:=_$(1))
    $(eval override mf_printsuffix:=($(1)))
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_announce_compile
# Description:  echo standardized string to announce source compilation
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_announce_compile =
	@$(echo) "+++ [$$(notdir $(mf_target))] $$(notdir $$<)$(tab)$(1)"
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_compile_c++
# Description:  compile a C++ source file
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_compile_c =
	@$(call __cf_announce_compile,$(1))
	@$(test) $(CC) $(CPPFLAGS) $(CFLAGS) -c $$< -o $$@
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_compile_c++
# Description:  compile a C++ source file
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_compile_c++ =
	@$(call __cf_announce_compile,$(1))
	@$(test) $(CXX) $(CPPFLAGS) $(CFLAGS) $(CXXFLAGS) -c $$< -o $$@
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_gen_dependencies
# Description:  generate source/header dependency info
#
# This is based on Scott McPeak's "Autodependencies with GNU make"
# described at http://scottmcpeak.com/autodepend/autodepend.html
#
#    $(CXX):   use compiler to generate .d file
#    mv:       rename .d file to .d.tmp
# transform .d.tmp into a usable .d with:
#    sed:      use FQPN for target
# additionally, the following ensures that the build still succeeds
# if source files get renamed while .d files exist:
#    echo:     add blank line
#    sed:    - strip the target (up-to and including colon)
#            - remove any continuation backslash
#    fmt -1:   list 'words' (files) one per line
#    sed:    - strip leading spaces
#            - add trailing colons (and blank lines)
#            - remove lines containing only a colon
# ---------------------------------------------------------------------
define __cf_gen_dependencies =
	@$(test2) $(CXX) -MM $(CPPFLAGS) $(CXXFLAGS) $$< $(redir)$(mf_outdir)/$(1).d
	@$(test2) mv -f $(mf_outdir)/$(1).d $(mf_outdir)/$(1).d.tmp
	@$(test2) sed -e 's|.*:|$(mf_outdir)/$(1).o:|' $(indir)$(mf_outdir)/$(1).d.tmp $(redir)$(mf_outdir)/$(1).d
	@$(test2) echo "" $(append)$(mf_outdir)/$(1).d
	@$(test2) sed -e 's/.*://' \
	              -e 's/\\$$$$//' $(indir)$(mf_outdir)/$(1).d.tmp $(pipe) \
	 $(test2) fmt -1 $(pipe) \
	 $(test2) sed -e 's/^ *//' \
	              -e 's/$$$$/:\n/' \
	              -e 's/^:.*$$$$/\n/' $(append)$(mf_outdir)/$(1).d
	@$(test2) $(RM) $(mf_outdir)/$(1).d.tmp
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_gen_static_pattern_rule_c++(obj, dir, glob)
# Description:  Generates a gnu-make "static pattern rule" based on
#               the passed-in arguments.
# Arguments: 1: The type of source code
#            2: FQPN of the object file that is the target of this
#               rule (This may have been name-mangled eith mf_suffix)
#            3: the directory where the source(s) are located
#            4: the file name (or file glob) to be compiled.
# ---------------------------------------------------------------------
define __cf_gen_static_pattern_rule
    $(2): $(mf_outdir)/%$(mf_suffix).$(mfobj): $(3)/%$(4) | $(mf_outdir)
	@$(call __cf_compile_$(1),$(mf_printsuffix))
	@$(call __cf_gen_dependencies,$$*$(mf_suffix))
endef


# ---------------------------------------------------------------------
# Function:     cf_add_sources(lang, dir, glob)
# Description:  Declares which sources need to be build for the current
#               target.  (This may be invoked multiple times as needed,
#               in each target.)
# Arguments: 1: name of the language being compiled (c++)
#            2: the directory where the source(s) are located
#            3: the file name (or file glob) to be compiled
# ---------------------------------------------------------------------
define $(CF)_add_sources =
    $(eval override _mfas_src:=$(wildcard $(2)/$(3)))
    $(eval override _mfas_ext:=$(suffix $(3)))
    $(eval override _mfas_obj:=$(subst $(_mfas_ext),$(mf_suffix).$(mfobj),$(_mfas_src)))
    $(eval override _mfas_obj:=$(subst $(2),$(mf_outdir),$(_mfas_obj)))
    $(eval override mf_srcfiles+=$(_mfas_src))
    $(eval override mf_objfiles+=$(_mfas_obj))
    $(eval $(call __cf_gen_static_pattern_rule,$(1),$(_mfas_obj),$(2),$(_mfas_ext)))
    $(eval undefine _mfas_src)
    $(eval undefine _mfas_ext)
    $(eval undefine _mfas_obj)
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_static_lib_dependency(target)
# Description:  support routine for mf_static_dependencies
# Arguments: 1: name of the build-target that builds the static
#               library that the current-target is dependendent upon.
#               From this, the library's filename is inferred to be
#               stored in mf_<target>_final
# ---------------------------------------------------------------------
define __cf_static_lib_dependency =
    $(eval override _mfsld_target:=$(1))
    $(eval override _mfsld_libfile:=$(mf_$(_mfsld_target)_final))
    $(eval override mf_deptargets+=$(_mfsld_target))
    $(eval override mf_linkfiles+=$(_mfsld_libfile))
    $(eval undefine _mfsld_libfile)
    $(eval undefine _mfsld_target)
endef


# ---------------------------------------------------------------------
# Function:     cf_static_dependencies(targets)
# Description:  Declares the current-target's static-lib linkage dependencies
# Arguments: 1: space-delimited list of build-targets
# ---------------------------------------------------------------------
define $(CF)_static_dependencies =
    $(eval override _mfsd_targets:=$(1))
    $(foreach target,$(_mfsd_targets),$(eval $(call __cf_static_lib_dependency,$(target))))
    $(eval undefine _mfsd_targets)
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_import_depfiles
# Description:  Support routine for mf_build_xxxxx routines
#               Includes (when present) all .d files that match the
#               target's objfiles
# ---------------------------------------------------------------------
define __cf_import_depfiles =
    $(eval override mf_depfiles:=$(mf_objfiles:.$(mfobj)=.d))
    -include $(mf_depfiles)
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_delete_mfout_files
# Description:  Helper routine to __cf_gen_cleantarget
# Arguments: 1: Space-delimited list of files to delete
# ---------------------------------------------------------------------
define __cf_delete_mfout_files =
	 ([ -e $(cfout) ] && $(test) $(RM) $(1)) || true;
endef


# ---------------------------------------------------------------------
# INTERNAL:     __cf_gen_cleantarget(target,filelist)
# Description:  Generates a clean-target for the current-target, and
#               adds it to the global list of clean-targets (to be
#               used by target 'clean')
# Arguments: 1: Name of the current-target (TODO: could just assume mf_target)
#            2: Space-delimited list of variable names, each containing
#               a space-delimited list of files to be deleted.
# ---------------------------------------------------------------------
define __cf_gen_cleantarget =
    # TODO: just use mf_target instead of passing it in as arg?
    $(eval override _mfgc_target:=$(1))
    $(eval override _mfgc_varnames:=$(2))

    .PHONY: _clean_$(_mfgc_target)
    _clean_$(_mfgc_target):
	@([ -e $(cfout) ] && $(echo) "+++ [$(_mfgc_target)] Cleaning...") || true
	@$(foreach _var,$(_mfgc_varnames),$(call __cf_delete_mfout_files,$($(_var))))

    $(eval override mf_clean_targets+=_clean_$(_mfgc_target))
endef


# ---------------------------------------------------------------------
#  INTERNAL:     __cf_build_final_target(filename,string)
#  Description:  Generates the 'final' target file of the current-target
#  Arguments: 1: The filename (stem[.ext]) of the file to be generated.
#             2: A string describing the type of file being built
# ---------------------------------------------------------------------
define __cf_build_final_target =
    $(eval override mf_$(mf_target)_final:=$(mf_outdir)/$(1))
    $(eval $(__cf_import_depfiles))
    $(eval override mf_objfiles:=$(sort $(mf_objfiles)))
    $(eval override mf_linkfiles:=$(sort $(mf_linkfiles)))

    $(mf_target): $(mf_deptargets) $(mf_$(mf_target)_final)

    $(eval $(call __cf_gen_cleantarget,$(mf_target),mf_objfiles mf_depfiles mf_$(mf_target)_final))
    $(mf_$(mf_target)_final): $(mf_objfiles) $(mf_linkfiles)
	@$(echo) +++ [$(mf_target)] Generating $(2) \'$$(notdir $$@)\'...
endef


# ---------------------------------------------------------------------
#  Function:     cf_build_static_library(stem)
#  Description:  This end the target definition for a static library
#  Arguments: 1: The stem of the static library's intended filename
# ---------------------------------------------------------------------
define $(CF)_build_static_library =
    $(call __cf_build_final_target,$(1).$(mflib),static library)
	@$(test) $(AR) $(ARFLAGS) $$@ $$^
endef


# ---------------------------------------------------------------------
#  Function:     cf_build_shared_library(stem)
#  Description:  This ends the target definition for a shared library.
#                This will add '-shared' to LDFLAGS
#  Arguments: 1: The stem of the shared library's intended filename
# ---------------------------------------------------------------------
define $(CF)_build_shared_library =
    # TODO, need an add-flags routine
    $(eval override LDFLAGS+=-shared)
    $(call __cf_build_final_target,$(1).$(mfdll),shared library)
	@$(test) $(CXX) $(LDFLAGS) $$^ -o $$@
endef


# ---------------------------------------------------------------------
#  Function:     cf_build_executable(stem)
#  Description:  This end the target definition for an executable
#  Arguments: 1: The stem of the executable's intended filename
# ---------------------------------------------------------------------
define $(CF)_build_executable =
    $(call __cf_build_final_target,$(1)$(mfexe),executable)
	@$(test) $(CXX) $(LDFLAGS) $$^ $(LDLIBS) -o $$@
endef


# ---------------------------------------------------------------------
#  Function:     cf_include_as(namespace,filepath)
#  Description:  This imports the make-forge fragment located at
#                'filepath', under the namespace 'namespace'
#  Arguments: 1: The desired namespace.  This does not have to be
#                unique, but it is generally recommended to be
#             2: Path to the make-forge fragment (.MF)
# ---------------------------------------------------------------------
#  TODO: enforce .MF extension?
define $(CF)_include_as =
    $(eval override CF_NAMESPACE:=$(1)@)
    $(call verbose,including '$(2)' as '$(1)')
    $(eval include $(2))
    $(eval override undefine CF_NAMESPACE)
endef


# each release adds another digit of i^i
mf_version_major:=0
mf_version_minor:=207879
mf_version_text:=... (beta release "i^i")
version::
	@echo "( build/test system: MAKE-FORGE, version $(mf_version_major).$(mf_version_minor)$(mf_version_text) )"
	@echo ""


$(eval $(call __cf_initialize))

endif  # __cf_include_guard
