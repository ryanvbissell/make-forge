# vim: set ft=make:
#
# Copyright (c) 2016-2017, Ryan V. Bissell
# All rights reserved.
#
# SPDX-License-Identifier: MIT
# See the enclosed "LICENSE.forge" file for exact license terms.
#

ifndef __cf_include_guard
override __cf_include_guard:=1


override empty:=
override tab:=$(empty)	$(empty)
override space:=$(empty) $(empty)
override comma:= ,
override semi:=;
override bspace:=$(empty)$(empty)
override ,:=$(comma)
override ;:=$(semi)


_cfcommon:=$(notdir $(lastword $(MAKEFILE_LIST)))
_cfcaller:=$(notdir $(lastword $(wordlist 2,$(words $(MAKEFILE_LIST)),foo $(MAKEFILE_LIST))))
cf_assert = $(if $($1),,\
              $(error INTERNAL ERROR:  $(_cfcaller) should have defined '$1' before including $(_cfcommon)))

$(call cf_assert,CF)
$(call cf_assert,cfout)

$(cfout):
	@$(test) mkdir -p $(cfout)


# TODO, see make-forge
########.PHONY: clean


# .d files are precious because they serve to speed up subsequent builds.
# .i files are precious because the user specifically asked for them.
.PRECIOUS: $(cfout)/%.d $(cfout)/%.i


# enable paralellism based on number of available processors
# I believe this is the most portable solution (nearly POSIX)
override CF_NUMPROCS?=$(shell getconf _NPROCESSORS_ONLN)
override MAKEFLAGS+= --jobs=$(CF_NUMPROCS)
ifdef VERBOSE
define verbose =
    $(info V: $1)
endef
endif
$(call verbose,This session will use $(cf_numprocs) processor(s))

ifndef CF_NOSYNC
# group parallel output on a per-target basis,
# XXX: this will make stderr undetectable by stderred
override MAKEFLAGS+= --output-sync=target
endif

# squelch unhelpful output from Make
override MAKEFLAGS+= --no-print-directory


# TODO: these should be specific to the host OS
override cfobj:=o
override cflib:=a
override cfexe:=
override cfdll:=so


# TODO: some of these may be specific to the host OS
ifdef TEST
    override test:=echo
    override test2:=>/dev/null $(test)
    override pipe:=\|
    override redir:=\>
    override indir:=\<
    override append:=\>\>
    ifeq ($(TEST),2)
        override test2:=$(test)
    endif
else
    override test:=
    override test2:=
    override pipe:=|
    override redir:=>
    override indir:=<
    override append:=>>
endif

ifdef DEBUG
    override CXXFLAGS+= -ggdb3 -O0
endif

override echo:=echo
ifdef CF_QUIET_BUILDS
    override echo:=>/dev/null echo
endif


# save off the original values of CXXFLAGS, etc, so that we
# can restore them a the start of every target declaration
override CF_CFLAGS:=$(CFLAGS)
override CF_LDFLAGS:=$(LDFLAGS)
override CF_CPPFLAGS:=$(CPPFLAGS)
override CF_CXXFLAGS:=$(CXXFLAGS)

# traditionally, ARFLAGS defaults to 'rv', but we like 'rcs' here
override CF_ARFLAGS:=rcs

# ---------------------------------------------------------------------
# INTERNAL:     (__cf_initialize)
# Description:  Resets internal state, in preparation for
#               cf_declare_target, et al.
# ---------------------------------------------------------------------
define __cf_initialize =
    $(eval override LDLIBS:=)
    $(eval override CFLAGS:=$(CF_CFLAGS))
    $(eval override ARFLAGS:=$(CF_ARFLAGS))
    $(eval override LDFLAGS:=$(CF_LDFLAGS))
    $(eval override CPPFLAGS:=$(CF_CPPFLAGS))
    $(eval override CXXFLAGS:=$(CF_CXXFLAGS))
    $(eval override cf_suffix:=)
    $(eval override cf_printsuffix:=)
    $(eval override cf_srcfiles:=)
    $(eval override cf_objfiles:=)
    $(eval override cf_depfiles:=)
    $(eval override cf_libfiles:=)
    $(eval override cf_linkfiles:=)
    $(eval override cf_deptargets:=)
endef


# ---------------------------------------------------------------------
# Function:     ($(CF)-declare-target,name)
# Description:  Declares to make-forge that a new build-target named
#               'name' is about to be described.
# Arguments: 1: name of the build-target being described
# ---------------------------------------------------------------------
define _cf_declare_target =
    $(call __cf_initialize)
    $(eval override cf_target:=$(CF_NAMESPACE)$(1))
    $(eval override cf_outdir:=$(cfout))
endef
$(CF)-declare-target = $(strip $(call _cf_declare_target,$1))


# ---------------------------------------------------------------------
# Function:     ($(CF)-set-object-suffix,suffix)
# Description:  Sets a filename stem suffix for every object file
#               built for this build-target
# Arguments: 1: What the suffix should be set to
# ---------------------------------------------------------------------
define _cf_set_object_suffix =
    $(eval override cf_suffix:=_$(1))
    $(eval override cf_printsuffix:=($(1)))
endef
$(CF)-set-object-suffix = $(strip $(call _cf_set_object_suffix,$1))


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_announce_compile)
# Description:  echo standardized string to announce source compilation
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_announce_compile =
	@$(echo) "+++ [$$(notdir $(cf_target))] $$(notdir $$<)$(tab)$(1)"
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_compile_C)
# Description:  compile a C++ source file
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_compile_C =
	@$(call __cf_announce_compile,$(1))
	@$(test) $(CC) $(CPPFLAGS) $(CFLAGS) -c $$< -o $$@
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_compile_C++)
# Description:  compile a C++ source file
# Arguments: 1: Parenthesized suffix, if set
# ---------------------------------------------------------------------
define __cf_compile_C++ =
	@$(call __cf_announce_compile,$(1))
	@$(test) $(CXX) $(CPPFLAGS) $(CFLAGS) $(CXXFLAGS) -c $$< -o $$@
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_gen_dependencies)
# Description:  generate source/header dependency info
#
# This is based on Scott McPeak's "Autodependencies with GNU make"
# described at http://scottmcpeak.com/autodepend/autodepend.html
#
#    $(CXX):   use compiler to generate .d file
#    mv:       rename .d file to .d.tmp
# transform .d.tmp into a usable .d with:
#    sed:      use FQPN for target
# additionally, the following ensures that the build still succeeds
# if source files get renamed while .d files exist:
#    echo:     add blank line
#    sed:    - strip the target (up-to and including colon)
#            - remove any continuation backslash
#    fmt -1:   list 'words' (files) one per line
#    sed:    - strip leading spaces
#            - add trailing colons (and blank lines)
#            - remove lines containing only a colon
# ---------------------------------------------------------------------
define __cf_gen_dependencies =
	@$(test2) $(CXX) -MM $(CPPFLAGS) $(CXXFLAGS) $$< $(redir)$(cf_outdir)/$(1).d
	@$(test2) mv -f $(cf_outdir)/$(1).d $(cf_outdir)/$(1).d.tmp
	@$(test2) sed -e 's|.*:|$(cf_outdir)/$(1).o:|' $(indir)$(cf_outdir)/$(1).d.tmp $(redir)$(cf_outdir)/$(1).d
	@$(test2) echo "" $(append)$(cf_outdir)/$(1).d
	@$(test2) sed -e 's/.*://' \
	              -e 's/\\$$$$//' $(indir)$(cf_outdir)/$(1).d.tmp $(pipe) \
	 $(test2) fmt -1 $(pipe) \
	 $(test2) sed -e 's/^ *//' \
	              -e 's/$$$$/:\n/' \
	              -e 's/^:.*$$$$/\n/' $(append)$(cf_outdir)/$(1).d
	@$(test2) $(RM) $(cf_outdir)/$(1).d.tmp
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_gen_static_pattern_rule,LANG,obj,dir,glob)
# Description:  Generates a gnu-make "static pattern rule" based on
#               the passed-in arguments.
# Arguments: 1: The NAME of the language being compiled (C, C++)
#            2: FQPN of the object file that is the target of this
#               rule (This may have been name-mangled eith cf_suffix)
#            3: the directory where the source(s) are located
#            4: the file name (or file glob) to be compiled.
# ---------------------------------------------------------------------
define __cf_gen_static_pattern_rule
    $(2): $(cf_outdir)/%$(cf_suffix).$(cfobj): $(3)/%$(4) | $(cf_outdir)
	@$(call __cf_compile_$(1),$(cf_printsuffix))
	@$(call __cf_gen_dependencies,$$*$(cf_suffix))
endef


# ---------------------------------------------------------------------
# Function:     ($(CF)-add-sources,LANG,dir,glob)
# Description:  Declares which sources need to be build for the current
#               target.  (This may be invoked multiple times as needed,
#               in each target.)
# Arguments: 1: NAME of the language being compiled (C,C++)
#            2: the directory where the source(s) are located
#            3: the file name (or file glob) to be compiled
# ---------------------------------------------------------------------
define _cf_add_sources =
    $(eval override _mfas_src:=$(wildcard $(2)/$(3)))
    $(eval override _mfas_ext:=$(suffix $(3)))
    $(eval override _mfas_obj:=$(subst $(_mfas_ext),$(cf_suffix).$(cfobj),$(_mfas_src)))
    $(eval override _mfas_obj:=$(subst $(2),$(cf_outdir),$(_mfas_obj)))
    $(eval override cf_srcfiles+=$(_mfas_src))
    $(eval override cf_objfiles+=$(_mfas_obj))
    $(eval $(call __cf_gen_static_pattern_rule,$(1),$(_mfas_obj),$(2),$(_mfas_ext)))
    $(eval undefine _mfas_src)
    $(eval undefine _mfas_ext)
    $(eval undefine _mfas_obj)
endef
$(CF)-add-sources = $(strip $(call _cf_add_sources,$1,$2,$3))


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_static_lib_dependency,target)
# Description:  support routine for cf_static_dependencies
# Arguments: 1: name of the build-target that builds the static
#               library that the current-target is dependendent upon.
#               From this, the library's filename is inferred to be
#               stored in cf_<target>_file
# ---------------------------------------------------------------------
define __cf_static_lib_dependency =
    $(eval override _mfsld_target:=$(1))
    $(eval override _mfsld_libfile:=$(cf_$(_mfsld_target)_file))
    $(eval override cf_deptargets+=$(_mfsld_target))
    $(eval override cf_linkfiles+=$(_mfsld_libfile))
    $(eval undefine _mfsld_libfile)
    $(eval undefine _mfsld_target)
endef


# ---------------------------------------------------------------------
# Function:     ($(CF)-static-dependencies,targets)
# Description:  Declares the current-target's static-lib linkage dependencies
# Arguments: 1: space-delimited list of build-targets
# ---------------------------------------------------------------------
define _cf_static_dependencies =
    $(eval override _mfsd_targets:=$(1))
    $(foreach target,$(_mfsd_targets),$(call __cf_static_lib_dependency,$(target)))
    $(eval undefine _mfsd_targets)
endef
$(CF)-static-dependencies = $(strip $(call _cf_static_dependencies,$1))


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_import_depfiles)
# Description:  Support routine for cf_build_xxxxx routines
#               Includes (when present) all .d files that match the
#               target's objfiles
# ---------------------------------------------------------------------
define __cf_import_depfiles =
    $(eval override cf_depfiles:=$(cf_objfiles:.$(cfobj)=.d))
    -include $(cf_depfiles)
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_delete_mfout_files,files)
# Description:  Helper routine to __cf_gen_cleantarget
# Arguments: 1: Space-delimited list of files to delete
# ---------------------------------------------------------------------
define __cf_delete_mfout_files =
	 ([ -e $(cfout) ] && $(test) $(RM) $(1)) || true;
endef


# ---------------------------------------------------------------------
# INTERNAL:     (__cf_gen_cleantarget,target,filelist)
# Description:  Generates a clean-target for the current-target, and
#               adds it to the global list of clean-targets (to be
#               used by target 'clean')
# Arguments: 1: Name of the current-target (TODO: could just assume cf_target)
#            2: Space-delimited list of variable names, each containing
#               a space-delimited list of files to be deleted.
# ---------------------------------------------------------------------
define __cf_gen_cleantarget =
    # TODO: just use cf_target instead of passing it in as arg?
    $(eval override _mfgc_target:=$(1))
    $(eval override _mfgc_varnames:=$(2))

    .PHONY: _clean_$(_mfgc_target)
    _clean_$(_mfgc_target):
	@([ -e $(cfout) ] && $(echo) "+++ [$(_mfgc_target)] Cleaning...") || true
	@$(foreach _var,$(_mfgc_varnames),$(call __cf_delete_mfout_files,$($(_var))))

    $(eval override cf_clean_targets+=_clean_$(_mfgc_target))
endef


# ---------------------------------------------------------------------
#  INTERNAL:     (__cf_build_target_file,filename,string)
#  Description:  Generates the ultimate target file of the current-target
#  Arguments: 1: The filename (stem[.ext]) of the file to be generated.
#             2: A string describing the type of file being built
# ---------------------------------------------------------------------
define __cf_build_target_file =
    $(eval override cf_$(cf_target)_file:=$(cf_outdir)/$(1))
    $(eval $(__cf_import_depfiles))
    $(eval override cf_objfiles:=$(sort $(cf_objfiles)))
    $(eval override cf_linkfiles:=$(sort $(cf_linkfiles)))

    $(cf_target): $(cf_deptargets) $(cf_$(cf_target)_file)

    $(eval $(call __cf_gen_cleantarget,$(cf_target),cf_objfiles cf_depfiles cf_$(cf_target)_file))
    $(cf_$(cf_target)_file): $(cf_objfiles) $(cf_linkfiles)
	@$(echo) +++ [$(cf_target)] Generating $(2) \'$$(notdir $$@)\'...
endef


# ---------------------------------------------------------------------
#  Function:     ($(CF)-build-static-library,stem)
#  Description:  This end the target definition for a static library
#  Arguments: 1: The stem of the static library's intended filename
# ---------------------------------------------------------------------
define _cf_build_static_library =
    $(call __cf_build_target_file,$(1).$(cflib),static library)
	@$(test) $(AR) $(ARFLAGS) $$@ $$^
endef
$(CF)-build-static-library = $(eval $(call _cf_build_static_library,$1))


# ---------------------------------------------------------------------
#  Function:     ($(CF)-build-shared-library,stem)
#  Description:  This ends the target definition for a shared library.
#                This will add '-shared' to LDFLAGS
#  Arguments: 1: The stem of the shared library's intended filename
# ---------------------------------------------------------------------
define _cf_build_shared_library =
    # TODO, need an add-flags routine
    $(eval override LDFLAGS+=-shared)
    $(call __cf_build_target_file,$(1).$(cfdll),shared library)
	@$(test) $(CXX) $(LDFLAGS) $$^ -o $$@
endef
$(CF)-build-shared-library = $(eval $(call _cf_build_shared_library,$1))


# ---------------------------------------------------------------------
#  Function:     ($(CF)-build-executable,stem)
#  Description:  This end the target definition for an executable
#  Arguments: 1: The stem of the executable's intended filename
# ---------------------------------------------------------------------
define _cf_build_executable =
    $(call __cf_build_target_file,$(1)$(cfexe),executable)
	@$(test) $(CXX) $(LDFLAGS) $$^ $(LDLIBS) -o $$@
endef
$(CF)-build-executable = $(eval $(call _cf_build_executable,$1))


# ---------------------------------------------------------------------
#  Function:     ($(CF)-include-as,namespace,filepath)
#  Description:  This imports the make-forge fragment located at
#                'filepath', under the namespace 'namespace'
#  Arguments: 1: The desired namespace.  This does not have to be
#                unique, but it is generally recommended to be
#             2: Path to the make-forge fragment (.MF)
# ---------------------------------------------------------------------
#  TODO: enforce .MF extension?
define $(CF)-include-as =
    $(eval override CF_NAMESPACE:=$(1)@)
    $(call verbose,including '$(2)' as '$(1)')
    $(eval include $(2))
    $(eval override undefine CF_NAMESPACE)
endef


# each release adds another digit of i^i
cf_version_major:=0
cf_version_minor:=207879
cf_version_text:=... (beta release "i^i")
version::
	@echo "( build/test system: MAKE-FORGE, version $(cf_version_major).$(cf_version_minor)$(cf_version_text) )"
	@echo ""


$(eval $(call __cf_initialize))

endif  # __cf_include_guard
